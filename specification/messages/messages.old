<!-- Reference Links -->
[1]:	https://www.broadband-forum.org/technical/download/TR-181_Issue-2_Amendment-12.pdf "TR-181 Issue 2 Device Data Model for TR-069"
[2]: https://www.broadband-forum.org/technical/download/TR-069.pdf	"TR-069 Amendment 6	CPE WAN Management Protocol"
[3]:	https://www.broadband-forum.org/technical/download/TR-106_Amendment-8.pdf "TR-106 Amendment 8	Data Model Template for TR-069 Enabled Devices"
[4]:	https://tools.ietf.org/html/rfc7228 "RFC 7228	Terminology for Constrained-Node Networks"
[5]:	https://tools.ietf.org/html/rfc2136	"RFC 2136 Dynamic Updates in the Domain Name System"
[6]:	https://tools.ietf.org/html/rfc3007	"RFC 3007 Secure Domain Name System Dynamic Update"
[7]:	https://tools.ietf.org/html/rfc6763	"RFC 6763 DNS-Based Service Discovery"
[8]:	https://tools.ietf.org/html/rfc6762	"RFC 6752 Multicast DNS"
[9]:	https://tools.ietf.org/html/rfc7252	"RFC 7252 The Constrained Application Protocol (CoAP)"
[10]:	https://tools.ietf.org/html/rfc7390	"RFC 7390 Group Communication for the Constrained Application Protocol (CoAP)"
[11]:	https://tools.ietf.org/html/rfc4033	"RFC 4033 DNS Security Introduction and Requirements"
[12]:	https://developers.google.com/protocol-buffers/docs/proto3 "Protocol Buffers v3	Protocol Buffers Mechanism for Serializing Structured Data Version 3"
[Conventions]: https://www.ietf.org/rfc/rfc2119.txt "Key words for use in RFCs to Indicate Requirement Levels"

# Protocol Messages Overview

*Note: This version of the specification defines its messages in [Protocol Buffers v3][12]. This part of the specification may change to a more generic description (normative and non-normative) if further encodings are specified in future versions.*

These sections describes the types of USP messages and the normative requirements for their flow and operation. USP messages are described in a protocol buffers schema, and the normative requirements for the individual elements of the schema are outlined below:

* [Add](add/)
* [Set](set/)
* [Delete](delete/)
* [Get](get/)
* [GetInstances](getinstances/)
* [GetSupportedDM](getsupoprtedDM/)
* [Notify](notify/)
* [Operate](operate/)

USP contains messages to create, read, update, and delete Objects, perform Object-defined operations, and allow agents to notify controllers of events. This is often referred to as CRUD with the addition of O (operate) and N (notify), or CRUD-ON.

##	Requests, Responses and Errors
<a id="requests_responses_and_errors" />

The three types of USP messages are Request, Response, and Error.

A request is a message sent from a source USP endpoint to a target USP endpoint that includes elements to be processed and returns a response or error. Unless otherwise specified, all requests have an associated response. Though the majority of requests are made from a Controller to an Agent, the Notify message follows the same format as a request but is sent from an Agent to a Controller.

**R-x.y** – The target USP endpoint MUST respond to a request message from the source USP endpoint with either a response message or error message, unless otherwise specified (see Operate and Notify messages).

**R-x.y** – The target USP endpoint MUST ignore or send an error message in response to messages it does not understand.

**R-x.y** – When the target USP endpoint is not required to send a response, the MTP endpoint that received the message MUST gracefully end the MTP message exchange. How the MTP gracefully ends the MTP message exchange is dependent on the type of MTP.

###	Handling Duplicate Messages
<a id="handling_duplicate_messages" />

Circumstances may arise (such as multiple Message Transfer Protocols) that cause duplicate messages (those with an identical message ID) to arrive at the target USP endpoint.

**R-x.y** – If a target USP endpoint receives a message with a duplicate message ID before it has processed and sent a Response or Error to the original message, it MUST gracefully ignore the duplicate message.

For messages that require no response, it is up to the target endpoint implementation when to allow the same message ID to be re-used by the same source USP endpoint.

###	Example Message Flows
<a id="example_message_flows" />

Successful request/response: In this successful message sequence, a Controller sends an Agent a request. The message header and body are parsed and the request is processed, and the Agent sends a response with the relevant information in the body.

<img src="successful_response.png" />
Figure 1 – A successful request/response sequence

Failed request/response: In this failed message sequence, a Controller sends an Agent a request. The message header and body are parsed and the request is processed, but throws an error. The error arguments are generated and sent in an error message.

<img src="error_response.png" />
Figure 2 – A failed request/response sequence

##	Message Structure
A Message consists of a header and body. When using [protocol buffers][12], the elements of the header and body for different messages are defined in a schema and sent in an encoded format from one USP endpoint to another.

**R-x.y** – A Message MUST conform to the schemas defined in [usp.proto](usp.proto).

*Note: When using protocol buffers for message encoding, default values (when elements are missing) are described in [Protcol Buffers v3](https://developers.google.com/protocol-buffers/docs/proto3#default).*

Every USP message contains a header and a body. The header contains basic destination and coordination information, and is separated to allow security and discovery mechanisms to operate. The body contains the message itself and its arguments.

Each of the message types and elements below are described with the element type according to [Protocol Buffers version 3][12], followed by its name.

### The USP Message
<a href="message_container" />

`Header header`

**R-x.y** – A Message MUST contain exactly one header element.

`Body body`

The Message Body that must be present in every Message.  The Body element contains either a Request, Response, or Error element.

**R-x.y** – A Message MUST contain exactly one body element.

###	Message Header
<a id="header" />

The message header contains information on source and target of the message, as well as useful coordination information. Its elements include a message ID, the endpoint identifiers for the source and target endpoints, an optional reply-to identifier, and a field indicating the type of message.

The purpose of the message header is to provide basic information necessary for the target endpoint to process the message.

#### Message Header Elements

`string msg_id`

A locally unique opaque identifier assigned by the Endpoint that generated this message.

**R-x.y** – The msg_id element MUST be present in every Header.

**R-x.y** – The msg_id element in the Message Header for a Response or Error that is associated with a Request MUST contain the message ID of the associated request. If the msg_id element in the Response or Error does not contain the message ID of the associated Request, the response or error MUST be ignored.

`enum MsgType msg_type`

This element contains an enumeration indicating the type of message contained in the message body. It is an enumeration of:

    ERROR (0)
    GET (1)
    GET_RESP (2)
    NOTIFY (3)
    SET (4)
    SET_RESP (5)
    OPERATE (6)
    OPERATE_RESP (7)
    ADD (8)
    ADD_RESP (9)
    DELETE (10)
    DELETE_RESP (11)
    GET_OBJECTS (12)
    GET_OBJECTS_RESP (13)
    NOTIFY_RESP (14)

**R-x.y** – The `msg_type` element MUST be present in every Header.

`string proto_version`

The version of the USP protocol.

**R-x.y** – The proto_version element MUST be present in every Header.

**R-x.y** – The proto_version element MUST be set to a value of “`1.0`”.

`string to_id`

The value of this header argument is the Endpoint Identifier of the target Endpoint.

**R-x.y** – The `to_id` element MUST be present in every Header.

**R-x.y** – The target USP endpoint MUST ignore any message that does not contain its own Endpoint Identifier.

`string from_id`

The value of this header argument is the Endpoint Identifier of the source Endpoint.

**R-x.y** – The `from_id` element MUST be present in every Header.

`string reply_to_id`

The value of this header argument is the Endpoint Identifier to which responses associated with this message should be targeted.

**R-x.y** – The `reply_to_id` MAY be used to send Response or Error to a USP Endpoint other than the from-to-id in the Request.

*Note: The reply-to endpoint should have prior knowledge of the message and can expect the Response or Error.*

**R-x.y** – The Source Endpoint MUST ignore a Response or Error message from a Target Endpoint when the Source Endpoint does not expect the Response or Error.

*Note: The reply-to endpoint should have prior knowledge of the message and can expect the Response.*

**R-x.y** – The `reply_to_id` element is optional, and MUST NOT be present in a Message that contains either a Response or Error in the Body element.

**R-x.y** – If the `reply_to_id` is omitted from a Message that contains a Request in the Body element, the response or Error MUST be sent to the Endpoint identified in the `from_id` element in the request’s Header element.

###	Message Body
<a id="body" />

The message body contains the intended message and the appropriate elements for the message type.

Every message body contains exactly one message and its elements. When an Agent is the target endpoint, these messages can be used to create, read, update, and delete Objects, or execute Object-defined operations. When a Controller is the target endpoint, the message will contain a notification, response, or an error.

#### Message Body Elements

`oneof msg_body`

This element contains one of the types given below.

`Request request`

This element indicates that the Message contains a request of a type given in the Request Message.

`Response response`

This element indicates that the Message contains a response of a type given in the Response Message.

`Error	error`

This element indicates that the Message contains an Error Message.

#### Request Elements
<a id="request" />

`oneof req_type`

This element contains one of the types given below. Each indicates that the Message contains a Message of the given type.

    Get get
    GetObjects get_Objects
    Set set
    Add add
    Delete delete
    Operate operate
    Notify notify

#### Response Elements
<a id="response" />

`oneof resp_type`

This element contains one of the types given below. Each indicates that the Message contains a Message of the given type.

    GetResp get_resp
    GetObjectsResp get_objects_resp
    SetResp set_resp
    AddResp add_resp		
    DeleteResp delete_resp		
    OperateResp operate_resp
    NotifyResp notify_resp		

#### Error Elements
<a id="error" />

`fixed32 err_code`

This element contains a [numeric code](/messages/error-codes/) indicating the type of error that caused the overall message to fail.

`string err_msg`

This element contains additional information about the reason behind the error.

`repeated ParamError`

This element is present in an Error Message in response to an Add or Set message when the allow_partial element is false and detailed error information is available for each Object or parameter that have caused the message to report an Error.

##### ParamError Elements

`string param_path`

This element contains a Path Name to the Object or parameter that caused the error.

`fixed32 err_code`

This element contains a [numeric code](/messages/error-codes/) indicating the type of error that caused the message to fail.

`string err_msg`

This element contains additional information about the reason behind the error.

##	Creating, Updating, and Deleting Objects
<a id="create_update_delete" />

The [Add](./add), [Set](./set), and [Delete](./delete) requests are used to create, configure and remove Objects that comprise Service Elements.

###	Selecting Objects and Parameters for CUD Operations
<a id="selecting_objects_and_parameters_CUD" />

Each Add, Set, and Delete request operates on one or more paths. For the Add request, these paths are references to Multi-Instance Objects. For all other requests, these paths can contain either addressing based identifiers that match zero or one Object or search based identifiers that matches one or more Objects.

For Add and Set requests, each Object address or search is conveyed in an element that also contains a sub-element listing the parameters to update in the matched Objects.

The Add response contains details about the success or failure of the creation of the Object and the parameters set during its creation. In addition, it also returns those parameters that were set by the Agent upon creation of the Object.

For example, a Controller wants to create a new Wifi network on an Agent. It could use an Add message with the following elements:

    allow_partial: false
    create_obj {
    	obj_path: Device.Wifi.SSID.
    	param_setting {

    		paramparam: LowerLayers
    		value: Device.Wifi.Radio.1.
    		required: True

    		paramparam: SSID
    		value: NewSSIDName
    		required: True
    		}
    	}

The Agent’s response would include the successful Object update and the list of parameters that were set, including the default values for the Enable and Status parameters defined in [Device:2][1]:

    created_obj_result {
      requested_path: Device.Wifi.SSID.
      oper_status {
        oper_success {
          instantiated_path: Device.Wifi.SSID.2.
          created_param_result_map:

          key: Enable
          value: false

          key: Status
          value: Down

          key: LowerLayers
          value: : Device.Wifi.Radio.1.

          key: SSID
          value: NewSSIDName: NewSSIDName				
        }
    }

In another example, a Controller wants to disable all of the Wifi networks on an Agent. It could use a Set message with the following elements:

    allow_partial: true
    update_obj {
      obj_path: Device.Wifi.SSID.*.
      param_setting {
        param: Enable
        value: False
        required: False
    }

Assuming the Agent had three Wifi SSIDs in its associated data model, it would return:

    updated_obj_result{
      requested_path: Device.Wifi.SSID.*.
      oper_status {
        oper_success {
          updated_inst_result {
            affected path: Device.WIfi.SSID.1.
            result_param_map:
            key: Enable
            value: False
          }
          updated_inst_result {
            affected path: Device.WIfi.SSID.2.
            result_param_map:
            key: Enable
            value: False
          }
          updated_inst_result {
            affected path: Device.WIfi.SSID.3.
            result_param_map:
            key: Enable:
            value: False
          }
      }

###	Using Allow Partial and Required Parameters
<a id="allow_partial_and_required_parameters" />

The Add, Set, and Delete requests contain an element called “`allow_partial`”. This element determines whether or not the message should be treated as one complete configuration change, or a set of individual changes, with regards to the success or failure of that configuration.

For Delete, this is straightforward - if `allow_partial` is `true`, the Agent should return a Response message with `affected_path_list` and `unaffected_path_err_list` containing the successfully deleted Objects and unsuccessfully deleted objects, respectively. If `allow_partial` is `false`, the Agent should return an Error message if any Objects fail to be deleted.

For the Add and Set messages, parameter updates contain an element called “`required`”. This details whether or not the update or creation of the Object should fail if a required parameter fails.

This creates a hierarchy of error conditions for the Add and Set requests, such as:

Parameter Error -> Object Error -> Message Error

If `allow_partial` is true, but one or more required parameters fail to be updated or configured, the creation or update of an individual Object fails. This results in an `oper_failure` in the `oper_status` element and `updated_obj_result` or `created_obj_result` returned in the Add or Set response.

If `allow_partial` is false, the failure of any required parameters will cause the update or creation of the Object to fail, which will cause the entire message to fail. In this case, the Agent returns an error message rather than a response message.

Both the `oper_failure` elements and Error messages contain an element called `param_error`, which contains elements of type `ParamError`. This is so that the Controller will receive the details of failed parameter updates regardless of whether or not the Agent returned a response message or error message.

The logic can be described as follows:

| `allow_partial`	| Required Parameters	| Required Parameter Failed	| Other Parameter Failed | 	Response/Error |	Oper_status of Object	| Contains param_error |
| -----: | :-----: | :-----: | :-----: | :-----: | :-----: | :----- |
| `True`/`False`	| No |-	|	No	| Response	| `oper_success`	| No |
| `True`/`False`	| No | - | Yes | Response | `oper_success` | Yes |
| `True`/`False` | Yes | No | No | Response | `oper_success` | No |
| `True`/`False` | Yes | No | Yes | Response | oper_success | Yes |
| `True` | Yes | Yes | - | Response | `oper_failure` | No |
| `False` | Yes | Yes | - | Error | `oper_failure` | Yes |

##	Reading an Agent’s State and Capabilities
<a id="read" />

An Agent’s current state and capabilities are represented in its data model. The current state is referred to as its Instantiated Data Model, while the data model that represents its set of capabilities is referred to as its Supported Data Model. Messages exist to retrieve data from both the instantiated and Supported Data Models.

###	Getting the current state
<a id="get_parameters" />

A Controller that wishes to learn the current state of an Agent usually wants to know one of two things: the current object instances that exist (and their unique keys for use in addressing), or the actual state of the Objects and Parameters represented by the Agent. These are handled by the GetInstances message, and the Get message, respectively.

#### Retrieving parameter values

The basic Get message is used to retrieve the values of a set of Object’s parameters in order to learn an Agent’s current state. It takes a set of search paths as an input and returns the complete tree of parameters, plus the parameters of all sub-Objects, of any Object matched by the specified expressions. The search paths specified in a Get request can also target individual parameters within Objects to be returned.

*Note: Those familiar with Broadband Forum [TR-069][2] will recognize this behavior as the difference between “partial paths” and “complete paths”. This behavior is replicated in USP for the Get message for each path that is matched by the expression(s) supplied in the request.*

*Note: Each search path is intended to be evaluated separately, and the results from a given search path are returned in an element dedicated to that path. As such, it is possible that the same information may be returned from more than one search path. This is intended, and the Agent should treat each search path atomically.*

The response returns an entry for each Path Name resolved by the path given in `requested_path`. If a path expression specified in the request does not match any valid parameters or Objects, the response will indicate that this expression was an “invalid path”, indicating that the Object or parameter does not currently exist in the Agent’s Instantiated Data Model.

For each resolved Path Name, a `ResolvedPathResult` message is given in the Response. This ResolvedPathResult contains the `resolved_path`, followed by a list of parameters of both the resolved_path Object and all of its sub-objects, plus their values. These Parameter Paths are Relative Paths to the `resolved_path`.

For example, a Controller wants to read the data model to learn the settings and stats of a single Wifi SSID, “HomeNetwork” with a BSSID of 00:11:22:33:44:55. It could use a Get request with the following elements:

    Get {
      param_path {
        Device.Wifi.SSID.[SSID="Homenetwork", BSSID=00:11:22:33:44:55].
      }
    }
In response to this request the Agent returns all parameters, plus sub-Objects and their parameters, of the addressed instance. The Agent returns this data in the Get response using an element for each of the requested paths. In this case:

    GetResp {
        req_path_result {
        requested_path: Device.Wifi.SSID.[SSID="Homenetwork",BSSID=00:11:22:33:44:55].
        err_code : 0
        err_msg :
        res_path_result_list {
          resolved_path : Device.Wifi.SSID.[SSID="Homenetwork",BSSID=00:11:22:33:44:55].
          result_parm_map {		
            key: 1.Enable
            value: True

            key: 1.Status
            value: Up

            key: 1.Name
            value: “Home Network”

            key: 1.LastChange
            value: 864000

            key: 1.BSSID
            value: 00:11:22:33:44:55

            key: 1.Stats.BytesSent
            value: 24901567

            key: 1.Stats.BytesReceived
            value: 892806908296

            etc.
          }
        }
      }

In another example, the Controller only wants to read the current status of the Wifi network with the SSID “HomeNetwork” with the BSSID of 00:11:22:33:44:55. It could use a Get request with the following elements:

    Get {
      param_path {
        Device.Wifi.SSID.[SSID=”Homenetwork”,BSSID=00:11:22:33:44:55].Status
      }
    }

In response to this request the Agent returns only the Status parameter and its value.

    GetResp {
      req_path_result {
        requested_path: Device.Wifi.SSID.[SSID=”Homenetwork”,BSSID=00:11:22:33:44:55].Status
        err_code : 0
        err_msg :
        res_path_result_list {
          resolved_path : Device.Wifi.SSID.[SSID="Homenetwork",BSSID=00:11:22:33:44:55].
          result_parm_map {
            key: Status
            value: Up
          }
        }
      }
    }

Lastly, using wildcards or another Search Path, the requested path may resolve to more than one resolved path. For example for a Request sent to an Agent with two `Wifi.SSID` instances:

```
    Get {
      param_path {
        Device.Wifi.SSID.*.Status
      }
    }
```

The Agent's GetResponse would be:

```
    GetResp {
      req_path_result {
        requested_path: Device.Wifi.SSID.*.
        err_code : 0
        err_msg :
        res_path_result_list {
          resolved_path : 1.
          result_parm_map {
            key: Status
            value: Up
          }

          resolved_path : 2.
          result_parm_map {
              key: Status
              value: Up
          }
        }
      }
    }
```
#### Retrieving Object Instances
<a id="get_instances" />

The GetInstances message takes a Path Name to an Object and requests that the Agent return the Instances of that Object that exist and *possibly* any Multi-Instance sub-Objects that exist as well as their Instances. This is used for getting a quick map of the Mutli-Instance Objects (i.e., tables) the Agent currently represents, and their unique keys, so that they can be addressed and manipulated later.

GetInstances takes one or more Path Names to Multi-Instance Objects in a Request to an Agent. In addition, both GetInstances and GetSupportedDM (below) make use of a flag called `next_level`, which determines whether or not the Response should include all of the sub-Objects that are children of the Object specified in `obj_path`. A value of `true` means that the Response should return data *only* for the Object specified. A value of false means that all sub-Objects should be resolved and returned.

For example, if a Controller wanted to know *only* the current instances of Wifi SSID Objects that exist on an Agent (that has 3 SSIDs), it would send a GetInstances Request as:

    GetInstances {
      obj_path : Device.Wifi.SSID.
      bool next_level : true
    }

The Agent's Response would contain:

    GetInstancesResp {
      req_path_result {
        requested_path : Device.Wifi.SSID.
        err_code : 0
        err_msg :
        curr_inst_list {
          instantiated_obj_path : Device.Wifi.SSID.1.
          unique_key_map :

            key : Alias
            value : UserWifi1

            key : Name
            value : UserWifi1

            key : SSID
            value : SecureProviderWifi

            key : BSSID
            value : 00:11:22:33:44:55

          instantiated_obj_path : Device.Wifi.SSID.2.
          unique_key_map :

            key : Alias
            value : UserWifi2

            key : Name
            value : UserWifi2

            key : SSID
            value : GuestProviderWifi

            key : BSSID
            value : 00:11:22:33:44:55

        }
      }
    }

In another example, the Controller wants to get all of  the Instances of the `Device.Wifi.AccessPoint` table, plus all of the instances of the AssociatedDevice Object and AC Object (sub-Objects of AccessPoint). It would issue a GetInstances Request with the following:

    GetInstances {
      obj_path : Device.Wifi.AccessPoint.
      bool next_level : false
    }

The Agent's Response will contain an entry in curr_inst_list for all of the Instances of the `Device.Wifi.AccessPoint` table, plus the Instances of the Multi-Instance sub-Objects `.AssociatedDevice.` and `.AC.`:

    GetInstancesResp {
      req_path_result {
        requested_path : Device.Wifi.AccessPoint.
        err_code : 0
        err_msg :
        curr_inst_list {
          instantiated_obj_path : Device.Wifi.AccessPoint.1.
          unique_key_map :

            key : Alias
            value : SomeAlias

            key : SSIDReference
            value : Device.Wifi.SSID.1

          instantiated_obj_path : Device.Wifi.AccessPoint.2.
          unique_key_map :

            key : Alias
            value : SomeAlias

            key : SSIDReference
            value : Device.Wifi.SSID.2

          instantiated_obj_path : Device.Wifi.AccessPoint.1.AssociatedDevice.1.
          unique_key_map :

            key : MACAddress
            value : 11:22:33:44:55:66

          instantiated_obj_path : Device.Wifi.AccessPoint.1.AC.1.
          unique_key_map :

            key : AccessCategory
            value : BE

          instantiated_obj_path : Device.Wifi.AccessPoint.2.AssociatedDevice.1.
          unique_key_map :

            key : MACAddress
            value : 11:22:33:44:55:66

          instantiated_obj_path : Device.Wifi.AccessPoint.2.AC.1.
          unique_key_map :

            key : AccessCategory
            value : BE
          }
        }
      }

Or more, if more Object Instances exist.

### Getting the Supported Data Model
<a id="get_supported" />

USP allows an Agent to specify which Objects, Parameters, Commands, and Events it supports in its Supported Data Model. These are defined in a Device Type document and referenced via a URL. The union of all of these Device Type documents defines the Agents Supported Data Model.

The GetSupoprtedDM message allows a Controller to retrieve information about the Supported Data Model as part of a USP message. While the Device Type documents and the definitions therein still hold, this message lets the Controller and Agent synchronize on the Supported Data Model as part of USP operation.



##	Notifications and Subscription Mechanism
<a id="notifications" />

A Controller can use the Subscription mechanism to subscribe to certain events that occur on the Agent, such as a parameter change, Object removal, wake-up, etc. When such event conditions are met, the Agent sends a [Notify message](notify/) to the Controller.

*Note: Those familiar with Broadband Forum [TR-069][2] will recall that a notification for a value change caused by an Auto-Configuration Server (ACS - the CWMP equivalent of a Controller) are not sent to the ACS. Since there is only a single ACS notifying the ACS of value changes it requested is unnecessary. This is not the case in USP: an Agent should follow the behavior specified by a subscription, regardless of the originator of that subscription.*

###	Using Subscription Objects

Subscriptions are maintained in instances of the Multi-Instance Subscription Object in the USP data model. The normative requirements for these Objects are described in the data model parameter descriptions for `Device.Subscription.{i}.` in [Device:2][1].

**R-x.y** – The Agent and Controller MUST follow the normative requirements defined in the `Device.Subscription.{i}.` Object specified in [Device:2][1].

####	ReferenceList Parameter

All subscriptions apply to one or more Objects or parameters in the Agent’s Instantiated Data Model. These are specified as Path Names or Search Paths in the `ReferenceList` parameter. The `ReferenceList` parameter may have different meaning depending on the nature of the notification subscribed to.

For example, a Controller wants to be notified when a new Wifi station joins the Wifi network. It uses the Add message to create a subscription Object instance with `Device.WiFi.AccessPoint.1.AssociatedDevice.` specified in the `ReferenceList` parameter and `ObjectCreation` as the `NotificationType`.

In another example, a Controller wants to be notified whenever an outside source changes the SSID of a Wifi network. It uses the Add message to create a subscription Object instance with `Device.Wifi.SSID.1.SSID` specified in the `ReferenceList` and `ValueChange` as the `NotificationType`.

####	Responses to Notifications and Notification Retry

The Notify request contains a flag, `send_resp`, that specifies whether or not the Controller should send a response message after receiving a Notify request. This is used in tandem with the `NotificationRetry` parameter in the subscription Object – if `NotificationRetry` is `true`, then the Agent sends its Notify requests with `send_resp : true`, and the Agent considers the notification delivered when it receives a response from the Controller. If `NotificationRetry` is `false`, the Agent does not need to use the `send_resp` flag and should ignore the delivery state of the notification.

If `NotificationRetry` is `true`, and the Agent does not receive a response from the Controller, it begins retrying using the retry algorithm below. The subscription Object also uses a `NotificationExpiration` parameter to specify when this retry should end if no success is ever achieved.

**R-x.y** – When retrying notifications, the Agent MUST use the following retry algorithm to manage the retransmission of the Notify request.

The retry interval range is controlled by two Parameters, the minimum wait interval and the interval multiplier, each of which corresponds to a data model Parameter, and which are described in the table below. The factory default values of these Parameters MUST be the default values listed in the Default column. They MAY be changed by a Controller with the appropriate permissions at any time.

| Descriptive Name | Symbol | Default | Data Model Parameter Name |
| ---------: | :-----: | :------: | :------------ |
|Minimum wait interval | m | 5 seconds |	`Device.Controller.{i}.USPRetryMinimumWaitInterval` |
| Interval multiplier |	k | 2000 | `Device.Controller.{i}.USPRetryIntervalMultiplier` |

| Retry Count | Default Wait Interval Range (min-max seconds) | Actual Wait Interval Range (min-max seconds) |
| ----------: | :---------: | :-------------- |
| #1 | 5-10 | m – m.(k/1000) |
| #2 | 10-20 | m.(k/1000) – m.(k/1000)2 |
| #3 | 20-40 | m.(k/1000)2 – m.(k/1000)3 |
| #4 | 40-80 | m.(k/1000)3 – m.(k/1000)4 |
| #5 | 80-160 | m.(k/1000)4 – m.(k/1000)5 |
| #6 | 160-320 | m.(k/1000)5 – m.(k/1000)6 |
| #7 | 320-640 | m.(k/1000)6 – m.(k/1000)7 |
| #8 | 640-1280 | m.(k/1000)7 – m.(k/1000)8 |
| #9 | 1280-2560 | m.(k/1000)8 – m.(k/1000)9 |
| #10 and subsequent | 2560-5120 | m.(k/1000)9 – m.(k/1000)10 |

**R-x.y** - Beginning with the tenth retry attempt, the Agent MUST choose from the fixed maximum range. The Agent will continue to retry a failed notification until it is successfully delivered or until the `NotificationExpiration` time is reached.

**R-x.y** – Once a notification is successfully delivered, the Agent MUST reset the retry count to zero for the next notification message.

**R-x.y** – If a reboot of the Agent occurs, the Agent MUST reset the retry count to zero for the next notification message.

####	Notification Types

There are several types events that can cause a Notify request. These include those that deal with changes to the Agent’s Instantiated Data Model (`ValueChange`, `ObjectCreation`, `ObjectDeletion`), the completion of an asynchronous Object-defined operation (`OperationComplete`), a policy-defined `OnBoardRequest`, and a generic `Event` for use with Object-defined events.

#####	ValueChange

The `ValueChange` notification is subscribed to by a Controller when it wants to know that the value of a single or set of parameters has changed from the state it was in at the time of the subscription, and then each time it changes from then on for the life of the subscription. It is triggered when this change occurs, even if it is caused by the originating Controller.

#####	 ObjectCreation and ObjectDeletion
These notifications are used for when an instance of the subscribed to Multi-Instance Objects is added or removed from the Agent’s Instantiated Data Model. Like `ValueChange`, this notification is triggered even if the subscribing Controller is the originator of the creation or deletion.

The `ObjectCreation` notification also includes the Object’s unique keys and their values as data in the notification.

#####	OnBoardRequest

The `OnBoardRequest` notification is used when the Agent has been specifically instructed to contact a Controller with a request for an on-boarding process (for example, when the Agent first comes online and is aware of the Controller). Unlike other notification requests, it is not handled via Subscription. Its use is meant to be driven by application policy, and is limited to those circumstances.

**R-x.y** – An Agent MUST send an `OnBoardRequest` Notify Request in the following circumstances:
1.	When the `OnBoardRequest()` command (defined in an instance of the `.Controller.` Object) is executed. This sends the notification request to the Controller that is the subject of that operation.

2.	When instructed to do so by internal application policy.

Further policy defines whether an OnBoardRequest requires a response. See the OnBoardRequest command defined in [Device:2][1].

#####	 OperationComplete

The `OperationComplete` notification is used to indicate that an asynchronous Object-defined operation finished (either successfully or unsuccessfully). These operations may also trigger other Events defined in the data model (see below).

#####	 Event
The `Event` notification is used to indicate that an Object-defined event was triggered on the Agent. These events are defined in the data model and include what parameters, if any, are returned as part of the notification.

##	Defined Operations Mechanism

Additional methods (operations) are and can be defined in the USP data model. Operations are generally defined on an Object, using the “command” attribute, as defined in [TR-106][3]. The mechanism is controlled using the [Operate message](operate/) in conjunction with the Multi-Instance Request Object.

###	Synchronous Operations

A synchronous operation is intended to complete immediately following its processing. When complete, the output arguments are sent in the Operate response. If the send_resp flag is false, the Controller doesn’t need the returned information (if any), and the Agent does not send an Operate Response.

<img src="synchronous_operation.png" />

Figure 3 – Operate Message Flow for Synchronous Operations

###	Asynchronous Operations

An asynchronous operation expects to take some processing on the system the Agent represents and will return results at a later time. When complete, the output arguments are sent in a `Notify` (`OperationComplete`) request to any Controllers that have an active subscription to the operation and Object(s) to which it applies.

When a Controller using the Operate request specifies an operation that is defined as asynchronous, the Agent creates an instance of the Request Object in its data model, and includes a reference to the created Object in the Operate response. If the `send_resp` flag is `false`, the Controller doesn’t need the Request details, and intends to ignore it.

The lifetime of a Request Object expires when the operation is complete (either by success or failure). An expired Request Object is removed from the Instantiated Data Model.

**R-x.y** – When an Agent receives an Operate Request that addresses an asynchronous operation, it MUST create a Request Object in the Request table of its Instantiated Data Model (see [Device:2][1]). When the Operation is complete (either success or failure), it MUST remove this Object from the Request table.

If any Controller wants a notification that an operation has completed, it creates a Subscription Object with the `NotificationType` set to `OperationComplete` and with the `ReferenceList` parameter including a path to the specified command. The Agent processes this Subscription when the operation completes and sends a Notify message, including the `command_key` value that the Controller assigned when making the Operate request.

<img src="asynchronous_operation.png" />

Figure 4 – Operate Message Flow for Asynchronous Operations

### Operate Requests on Multiple Objects

Since the Operate request can take a path expression as a value for the command element, it is possible to invoke the same operation on multiple valid Objects as part of a single Operate request. Responses to requests to Operate on more than one Object are handled using the `OperationResult` element type, which is returned as a repeated set in the Operate Response. The success or failure of the operation on each Object is handled separately and returned in a different `OperationResult` entry. For this reason, operation failures are never conveyed in an Error message – in reply to an Operate request, Error is only used when the message itself fails for one or more reasons, rather than the operation invoked.

**R-x.y** – An Agent MUST NOT send an Error message due to a failed operation. It MUST instead include the failure in the `cmd_failure` element of the Operate response.

**R-x.y** – For asynchronous operations the Agent MUST create a separate Request Object for each Object and associated operation matched in the command element.

###	Event Notifications for Operations

When an operation triggers an Event notification, the Agent sends the Event notification for all subscribed recipients as described [above](#notifications_and_subscrptions

### Concurrent Operations

If an asynchronous operation is triggered multiple times by one or more Controllers, the Agent has the following options:

1. Deny the new operation (with, for example, `7005 Resources Exceeded` )
2. The operations are performed in parallel and independently.
3. The operations are queued and completed in order.

**R-x.y** - When handling concurrently invoked operations, an Agent MUST NOT cancel an operation already in progress unless explicitly told to do so by a Controller with permission to do so.
